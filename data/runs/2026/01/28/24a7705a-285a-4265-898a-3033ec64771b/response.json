{
  "text": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Voxel World</title>\n    <script src=\"https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js\"></script>\n    <script src=\"https://cdn.tailwindcss.com\"></script>\n    <style>\n        body {\n            margin: 0;\n            overflow: hidden;\n            font-family: 'Courier New', monospace;\n        }\n        #canvas {\n            display: block;\n        }\n        #crosshair {\n            position: fixed;\n            top: 50%;\n            left: 50%;\n            transform: translate(-50%, -50%);\n            width: 20px;\n            height: 20px;\n            border: 2px solid white;\n            pointer-events: none;\n        }\n        #inventory {\n            position: fixed;\n            bottom: 20px;\n            left: 50%;\n            transform: translateX(-50%);\n            background: rgba(0, 0, 0, 0.8);\n            padding: 10px;\n            border-radius: 5px;\n            display: flex;\n            gap: 10px;\n            pointer-events: none;\n        }\n        .block-type {\n            width: 40px;\n            height: 40px;\n            border: 3px solid transparent;\n        }\n        .block-type.selected {\n            border-color: white;\n        }\n    </style>\n</head>\n<body>\n    <div id=\"crosshair\"></div>\n    <div id=\"inventory\"></div>\n    <script>\n        const scene = new THREE.Scene();\n        scene.fog = new THREE.Fog(0x87ceeb, 10, 100);\n\n        const renderer = new THREE.WebGLRenderer({ antialias: true, canvas: document.createElement('canvas') });\n        renderer.setSize(window.innerWidth, window.innerHeight);\n        renderer.shadowMap.enabled = true;\n        renderer.shadowMap.type = THREE.PCFSoftShadowMap;\n        document.body.appendChild(renderer.domElement);\n\n        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);\n        camera.position.set(0, 10, 0);\n\n        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);\n        scene.add(ambientLight);\n\n        const sunLight = new THREE.DirectionalLight(0xffdd99, 1);\n        sunLight.position.set(50, 100, 50);\n        sunLight.castShadow = true;\n        sunLight.shadow.mapSize.width = 2048;\n        sunLight.shadow.mapSize.height = 2048;\n        scene.add(sunLight);\n\n        const blockTypes = {\n            'grass': { color: 0x4a7023, top: 0x74b246 },\n            'dirt': { color: 0x8b4513 },\n            'stone': { color: 0x808080 },\n            'sand': { color: 0xf4e8b4 },\n            'leaves': { color: 0x2d4c1e },\n            'wood': { color: 0x8b4513, top: 0x694629 },\n            'glass': { color: 0x87ceeb, transparent: true, opacity: 0.5 }\n        };\n\n        const world = {};\n        const worldSize = 50;\n\n        function getChunkKey(x, z) {\n            return `${Math.floor(x / 16)},${Math.floor(z / 16)}`;\n        }\n\n        function getVoxel(x, y, z) {\n            const chunkKey = getChunkKey(x, z);\n            if (!world[chunkKey]) return 0;\n            return world[chunkKey][getVoxelIndex(x, y, z)] ?? 0;\n        }\n\n        function setVoxel(x, y, z, type) {\n            const chunkKey = getChunkKey(x, z);\n            if (!world[chunkKey]) world[chunkKey] = new Array(16 * 256 * 16).fill(0);\n            world[chunkKey][getVoxelIndex(x, y, z)] = type;\n        }\n\n        function getVoxelIndex(x, y, z) {\n            const chunkX = Math.floor(x) % 16;\n            const chunkZ = Math.floor(z) % 16;\n            return chunkX + (chunkZ * 16) + (y * 256);\n        }\n\n        function generateChunk(chunkX, chunkZ) {\n            const key = `${chunkX},${chunkZ}`;\n            if (world[key]) return;\n\n            const chunk = new Array(16 * 256 * 16).fill(0);\n\n            const offsetX = chunkX * 16;\n            const offsetZ = chunkZ * 16;\n\n            for (let x = 0; x < 16; x++) {\n                for (let z = 0; z < 16; z++) {\n                    const worldX = offsetX + x;\n                    const worldZ = offsetZ + z;\n                    const height = Math.floor(noise(worldX * 0.1, worldZ * 0.1) * 10) + 10;\n\n                    for (let y = 0; y < height; y++) {\n                        if (y === height - 1) {\n                            chunk[x + (z * 16) + (y * 256)] = 1; // grass\n                        } else if (y >= height - 3) {\n                            chunk[x + (z * 16) + (y * 256)] = 2; // dirt\n                        } else if (y < 5) {\n                            chunk[x + (z * 16) + (y * 256)] = 3; // stone\n                        }\n                    }\n                }\n            }\n\n            world[key] = chunk;\n        }\n\n        function noise(x, y) {\n            const floorX = Math.floor(x);\n            const floorY = Math.floor(y);\n            const fractX = x - floorX;\n            const fractY = y - floorY;\n            const v1 = perlin(floorX, floorY, 0);\n            const v2 = perlin(floorX + 1, floorY, 0);\n            const v3 = perlin(floorX, floorY + 1, 0);\n            const v4 = perlin(floorX + 1, floorY + 1, 0);\n            const i1 = lerp(v1, v2, fractX);\n            const i2 = lerp(v3, v4, fractX);\n            return lerp(i1, i2, fractY);\n        }\n\n        function perlin(x, y, z) {\n            const F = 0.5;\n            const G = 2;\n            x = x * G + 100;\n            y = y * G + 100;\n            z = z * G + 100;\n            const X = Math.floor(x) & 255;\n            const Y = Math.floor(y) & 255;\n            const Z = Math.floor(z) & 255;\n            x -= Math.floor(x);\n            y -= Math.floor(y);\n            z -= Math.floor(z);\n            const u = fade(x);\n            const v = fade(y);\n            const w = fade(z);\n            const A = p[X] + Y;\n            const AA = p[A] + Z;\n            const AB = p[A + 1] + Z;\n            const B = p[X + 1] + Y;\n            const BA = p[B] + Z;\n            const BB = p[B + 1] + Z;\n            return lerp(w, lerp(v, lerp(u, grad(p[AA], x, y, z), grad(p[BA], x - 1, y, z)), lerp(u, grad(p[AB], x, y - 1, z), grad(p[BB], x - 1, y - 1, z))), lerp(v, lerp(u, grad(p[AA + 1], x, y, z - 1), grad(p[BA + 1], x - 1, y, z - 1)), lerp(u, grad(p[AB + 1], x, y - 1, z - 1), grad(p[BB + 1], x - 1, y - 1, z - 1))));\n        }\n\n        function fade(t) {\n            return t * t * t * (t * (t * 6 - 15) + 10);\n        }\n\n        function lerp(t, a, b) {\n            return a + t * (b - a);\n        }\n\n        function grad(hash, x, y, z) {\n            const h = hash & 15;\n            const u = h < 8 ? x : y;\n            const v = h < 4 ? y : h === 12 || h === 14 ? x : z;\n            return ((h & 1) === 0 ? u : -u) + ((h & 2) === 0 ? v : -v);\n        }\n\n        const p = new Array(512);\n        const permutation = [151,160,137,91,90,15,131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,190,6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,88,237,149,56,87,174,20,125,136,171,168,68,175,74,165,71,134,139,48,27,166,77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,102,143,54,65,25,63,161,1,216,80,73,209,76,132,187,208,89,18,169,200,196,135,130,116,188,159,86,164,100,109,198,173,186,3,64,52,217,226,250,124,123,5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,223,183,170,213,119,248,152,2,44,154,163,70,221,153,101,155,167,43,172,9,129,22,39,253,19,98,108,110,79,113,224,232,178,185,112,104,218,246,97,228,251,34,242,193,238,210,144,12,191,179,162,241,81,51,145,235,249,14,239,107,49,192,214,31,181,199,106,157,184,84,204,176,115,121,50,45,127,4,150,254,138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180];\n        for (let i = 0; i < 256; i++) p[256 + i] = p[i] = permutation[i];\n\n        const voxelMeshes = {};\n        const chunkMeshes = {};\n\n        function updateChunksInView() {\n            const range = 4;\n            const playerChunkX = Math.floor(camera.position.x / 16);\n            const playerChunkZ = Math.floor(camera.position.z / 16);\n\n            for (let x = playerChunkX - range; x <= playerChunkX + range; x++) {\n                for (let z = playerChunkZ - range; z <= playerChunkZ + range; z++) {\n                    generateChunk(x, z);\n                    if (!chunkMeshes[`${x},${z}`]) createMeshForChunk(x, z);\n                }\n            }\n        }\n\n        function createMeshForChunk(chunkX, chunkZ) {\n            const key = `${chunkX},${chunkZ}`;\n            if (!world[key]) return;\n\n            const group = new THREE.Group();\n            const offsetX = chunkX * 16;\n            const offsetZ = chunkZ * 16;\n\n            for (let x = 0; x < 16; x++) {\n                for (let y = 0; y < 256; y++) {\n                    for (let z = 0; z < 16; z++) {\n                        const blockType = world[key][x + (z * 16) + (y * 256)];\n                        if (blockType > 0) {\n                            const worldX = offsetX + x;\n                            const worldY = y;\n                            const worldZ = offsetZ + z;\n\n                            if (shouldRenderBlock(worldX, worldY, worldZ, blockType)) {\n                                const mesh = createBlock(worldX, worldY, worldZ, blockType);\n                                group.add(mesh);\n                            }\n                        }\n                    }\n                }\n            }\n\n            scene.add(group);\n            chunkMeshes[key] = group;\n        }\n\n        function shouldRenderBlock(x, y, z, type) {\n            if (getVoxel(x + 1, y, z) === 0) return true;\n            if (getVoxel(x - 1, y, z) === 0) return true;\n            if (getVoxel(x, y + 1, z) === 0) return true;\n            if (getVoxel(x, y - 1, z) === 0) return true;\n            if (getVoxel(x, y, z + 1) === 0) return true;\n            if (getVoxel(x, y, z - 1) === 0) return true;\n            return false;\n        }\n\n        function createBlock(x, y, z, type) {\n            const geometry = new THREE.BoxGeometry(1, 1, 1);\n            const block = blockTypes[Object.keys(blockTypes)[type - 1]];\n            const material = new THREE.MeshLambertMaterial({\n                color: block.color,\n                transparent: block.transparent ?? false,\n                opacity: block.opacity ?? 1\n            });\n\n            const mesh = new THREE.Mesh(geometry, material);\n            mesh.position.set(x + 0.5, y + 0.5, z + 0.5);\n            mesh.castShadow = true;\n            mesh.receiveShadow = true;\n\n            return mesh;\n        }\n\n        let currentBlockType = 1;\n\n        function createCrosshair() {\n            const crosshair = document.createElement('div');\n            crosshair.id = 'crosshair';\n            document.body.appendChild(crosshair);\n        }\n\n        function createInventory() {\n            const inventory = document.createElement('div');\n            inventory.id = 'inventory';\n\n            Object.entries(blockTypes).forEach(([name, props], index) => {\n                const blockEl = document.createElement('div');\n                blockEl.className = 'block-type';\n                if (index === 0) blockEl.classList.add('selected');\n                blockEl.style.backgroundColor = `rgb(${Object.values(props.color).join(',')})`;\n                blockEl.onclick = () => selectBlockType(index + 1);\n                inventory.appendChild(blockEl);\n            });\n\n            document.body.appendChild(inventory);\n        }\n\n        function selectBlockType(type) {\n            currentBlockType = type;\n            const blocks = document.querySelectorAll('.block-type');\n            blocks.forEach(block => block.classList.remove('selected'));\n            blocks[type - 1].classList.add('selected');\n        }\n\n        const raycaster = new THREE.Raycaster();\n        const mouse = new THREE.Vector2();\n\n        function handleMouseDown(event) {\n            if (event.button === 0) destroyBlock();\n            if (event.button === 2) placeBlock();\n        }\n\n        function destroyBlock() {\n            raycaster.ray.origin.copy(camera.position);\n            raycaster.ray.direction.copy(camera.getWorldDirection(new THREE.Vector3()));\n            const intersections = raycaster.intersectObjects(scene.children.flatMap(child => child.children));\n            \n            if (intersections.length > 0) {\n                const voxel = intersections[0].object;\n                const position = voxel.position.toArray().map(Math.floor);\n                setVoxel(...position, 0);\n                voxel.parent.remove(voxel);\n            }\n        }\n\n        function placeBlock() {\n            raycaster.ray.origin.copy(camera.position);\n            raycaster.ray.direction.copy(camera.getWorldDirection(new THREE.Vector3()));\n            const intersections = raycaster.intersectObjects(scene.children.flatMap(child => child.children));\n\n            if (intersections.length > 0) {\n                const face = intersections[0].face.normal;\n                const position = intersections[0].point.toArray().map(Math.floor);\n                position[0] += face.x;\n                position[1] += face.y;\n                position[2] += face.z;\n\n                if (getVoxel(...position) === 0) {\n                    setVoxel(...position, currentBlockType);\n                    createMeshForChunk(Math.floor(position[0] / 16), Math.floor(position[2] / 16));\n                }\n            }\n        }\n\n        document.addEventListener('mousedown', handleMouseDown);\n        document.addEventListener('contextmenu', event => event.preventDefault());\n\n        let time = 0;\n\n        function animate() {\n            time += 0.01;\n\n            sunLight.position.set(\n                50 * Math.cos(time),\n                50 + 30 * Math.sin(time),\n                50 * Math.sin(time)\n            );\n\n            sunLight.color.setHSL((Math.sin(time) + 1) / 2, 0.5, 0.5);\n            ambientLight.intensity = 0.6 + 0.2 * Math.sin(time);\n\n            updateChunksInView();\n            renderer.render(scene, camera);\n            requestAnimationFrame(animate);\n        }\n\n        createCrosshair();\n        createInventory();\n        updateChunksInView();\n        animate();\n\n        window.addEventListener('resize', () => {\n            camera.aspect = window.innerWidth / window.innerHeight;\n            camera.updateProjectionMatrix();\n            renderer.setSize(window.innerWidth, window.innerHeight);\n        });\n    </script>\n</body>\n</html>"
}