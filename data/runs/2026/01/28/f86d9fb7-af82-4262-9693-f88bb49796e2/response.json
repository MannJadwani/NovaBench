{
  "text": "```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Voxel Craft 3D</title>\n    <script src=\"https://cdn.tailwindcss.com\"></script>\n    <style>\n        body { margin: 0; overflow: hidden; background-color: #87CEEB; user-select: none; }\n        #crosshair {\n            position: absolute;\n            top: 50%;\n            left: 50%;\n            width: 20px;\n            height: 20px;\n            background-image: url('data:image/svg+xml;utf8,<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"20\" height=\"20\" viewBox=\"0 0 20 20\"><path d=\"M9 0h2v20H9z\" fill=\"white\" stroke=\"black\" stroke-width=\"1\"/><path d=\"M0 9h20v2H0z\" fill=\"white\" stroke=\"black\" stroke-width=\"1\"/></svg>');\n            transform: translate(-50%, -50%);\n            pointer-events: none;\n            z-index: 10;\n        }\n        .hotbar-slot {\n            transition: transform 0.1s, border-color 0.1s;\n        }\n        .hotbar-slot.active {\n            transform: scale(1.1);\n            border-color: white;\n            box-shadow: 0 0 10px rgba(255,255,255,0.5);\n        }\n        /* Custom scrollbar for instructions if needed */\n        ::-webkit-scrollbar { width: 8px; }\n        ::-webkit-scrollbar-track { background: rgba(0,0,0,0.1); }\n        ::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.3); border-radius: 4px; }\n    </style>\n    <!-- Import Maps for Three.js -->\n    <script type=\"importmap\">\n        {\n            \"imports\": {\n                \"three\": \"https://unpkg.com/three@0.160.0/build/three.module.js\",\n                \"three/addons/\": \"https://unpkg.com/three@0.160.0/examples/jsm/\"\n            }\n        }\n    </script>\n</head>\n<body class=\"font-sans text-white\">\n\n    <!-- UI Overlay -->\n    <div id=\"ui-layer\" class=\"absolute inset-0 pointer-events-none flex flex-col justify-between p-6 z-20\">\n        \n        <!-- Top Bar -->\n        <div class=\"flex justify-between items-start\">\n            <div class=\"bg-black/50 backdrop-blur-sm p-4 rounded-lg border border-white/20\">\n                <h1 class=\"text-2xl font-bold bg-clip-text text-transparent bg-gradient-to-r from-green-400 to-blue-500\">VOXEL CRAFT</h1>\n                <p class=\"text-xs text-gray-300 mt-1\">FPS: <span id=\"fps-counter\">60</span></p>\n            </div>\n            \n            <div class=\"bg-black/50 backdrop-blur-sm p-4 rounded-lg border border-white/20 text-right\">\n                <h2 class=\"font-bold text-yellow-400 mb-2\">Controls</h2>\n                <ul class=\"text-sm space-y-1 text-gray-200\">\n                    <li><span class=\"bg-white/20 px-1 rounded\">W A S D</span> Move</li>\n                    <li><span class=\"bg-white/20 px-1 rounded\">SPACE</span> Jump</li>\n                    <li><span class=\"bg-white/20 px-1 rounded\">SHIFT</span> Crouch</li>\n                    <li><span class=\"bg-white/20 px-1 rounded\">L-Click</span> Break Block</li>\n                    <li><span class=\"bg-white/20 px-1 rounded\">R-Click</span> Place Block</li>\n                    <li><span class=\"bg-white/20 px-1 rounded\">1-5</span> Select Block</li>\n                </ul>\n            </div>\n        </div>\n\n        <!-- Crosshair -->\n        <div id=\"crosshair\"></div>\n\n        <!-- Bottom Bar (Hotbar) -->\n        <div class=\"flex justify-center mb-4\">\n            <div class=\"bg-black/60 backdrop-blur-md p-2 rounded-xl flex gap-2 border border-white/10\">\n                <!-- Generated by JS -->\n                <div id=\"hotbar-container\" class=\"flex gap-2\"></div>\n            </div>\n        </div>\n    </div>\n\n    <!-- Start Screen -->\n    <div id=\"start-screen\" class=\"absolute inset-0 bg-black/80 z-50 flex items-center justify-center flex-col backdrop-blur-md\">\n        <h1 class=\"text-6xl font-black mb-4 text-transparent bg-clip-text bg-gradient-to-br from-green-400 via-blue-500 to-purple-600\">VOXEL CRAFT</h1>\n        <p class=\"text-xl text-gray-300 mb-8\">Procedural World Generation • First Person • Sandbox</p>\n        <button id=\"start-btn\" class=\"px-8 py-4 bg-green-600 hover:bg-green-500 text-white font-bold rounded-lg text-xl transition transform hover:scale-105 shadow-[0_0_20px_rgba(34,197,94,0.6)]\">\n            CLICK TO START\n        </button>\n    </div>\n\n    <!-- Game Canvas -->\n    <canvas id=\"gl\" class=\"block w-full h-full\"></canvas>\n\n    <script type=\"module\">\n        import * as THREE from 'three';\n        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';\n\n        // --- Configuration ---\n        const WORLD_SIZE = 60; // Render distance radius\n        const CHUNK_HEIGHT = 30;\n        const GRAVITY = 30.0;\n        const JUMP_FORCE = 10.0;\n        const SPEED = 8.0;\n        const CROUCH_SPEED = 4.0;\n        const REACH = 6;\n\n        // --- Block Types ---\n        const BLOCK_TYPES = [\n            { id: 1, name: 'Grass', color: '#5C9E63', sideColor: '#5d4037', bottomColor: '#5d4037' }, // Special handling for grass\n            { id: 2, name: 'Dirt', color: '#5d4037' },\n            { id: 3, name: 'Stone', color: '#757575' },\n            { id: 4, name: 'Wood', color: '#3e2723' },\n            { id: 5, name: 'Leaves', color: '#2e7d32', transparent: true },\n            { id: 6, name: 'Sand', color: '#e6c075' },\n            { id: 7, name: 'Water', color: '#29b6f6', transparent: true, opacity: 0.7 },\n            { id: 8, name: 'Bricks', color: '#b71c1c' },\n        ];\n\n        // --- State ---\n        let camera, scene, renderer, controls;\n        let raycaster;\n        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false, canJump = false;\n        let isCrouching = false;\n        let prevTime = performance.now();\n        const velocity = new THREE.Vector3();\n        const direction = new THREE.Vector3();\n        \n        // World Data: Map \"x,y,z\" -> blockId\n        const worldData = new Map();\n        const meshes = {}; // blockId -> InstancedMesh\n        const dummy = new THREE.Object3D();\n        let highlightMesh;\n        \n        let selectedBlockId = 1;\n        \n        // Simple Noise function (Simplex-like)\n        // A simple pseudo-random noise generator to keep it self-contained\n        function noise(x, z) {\n            const sin = Math.sin;\n            const cos = Math.cos;\n            return (sin(x * 0.1) + cos(z * 0.1) + sin(x * 0.3 + z * 0.2) * 0.5) * 0.5 + 0.5;\n        }\n\n        // --- Initialization ---\n        function init() {\n            // Scene\n            scene = new THREE.Scene();\n            scene.background = new THREE.Color(0x87CEEB);\n            scene.fog = new THREE.Fog(0x87CEEB, 10, WORLD_SIZE * 1.5);\n\n            // Camera\n            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);\n            camera.position.y = 25; // Start high to fall down\n\n            // Lights\n            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);\n            scene.add(ambientLight);\n\n            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);\n            dirLight.position.set(50, 100, 50);\n            dirLight.castShadow = true;\n            dirLight.shadow.mapSize.width = 2048;\n            dirLight.shadow.mapSize.height = 2048;\n            dirLight.shadow.camera.near = 0.5;\n            dirLight.shadow.camera.far = 500;\n            dirLight.shadow.camera.left = -100;\n            dirLight.shadow.camera.right = 100;\n            dirLight.shadow.camera.top = 100;\n            dirLight.shadow.camera.bottom = -100;\n            scene.add(dirLight);\n            \n            // Day/Night Cycle Light (Sun/Moon)\n            window.sunLight = dirLight;\n\n            // Renderer\n            renderer = new THREE.WebGLRenderer({ canvas: document.querySelector('#gl'), antialias: true });\n            renderer.setPixelRatio(window.devicePixelRatio);\n            renderer.setSize(window.innerWidth, window.innerHeight);\n            renderer.shadowMap.enabled = true;\n            renderer.shadowMap.type = THREE.PCFSoftShadowMap;\n\n            // Controls\n            controls = new PointerLockControls(camera, document.body);\n\n            const startBtn = document.getElementById('start-btn');\n            const startScreen = document.getElementById('start-screen');\n\n            startBtn.addEventListener('click', () => {\n                controls.lock();\n            });\n\n            controls.addEventListener('lock', () => {\n                startScreen.style.display = 'none';\n            });\n\n            controls.addEventListener('unlock', () => {\n                startScreen.style.display = 'flex';\n            });\n\n            // Raycaster\n            raycaster = new THREE.Raycaster();\n            raycaster.far = REACH;\n\n            // Highlight Block (Cursor)\n            const hlGeo = new THREE.BoxGeometry(1.05, 1.05, 1.05);\n            const hlMat = new THREE.MeshBasicMaterial({ color: 0x000000, wireframe: true, opacity: 0.5, transparent: true });\n            highlightMesh = new THREE.Mesh(hlGeo, hlMat);\n            scene.add(highlightMesh);\n            highlightMesh.visible = false;\n\n            // Generate World\n            generateWorld();\n            setupInputs();\n            setupUI();\n\n            // Resize Handler\n            window.addEventListener('resize', onWindowResize);\n\n            // Loop\n            renderer.setAnimationLoop(animate);\n        }\n\n        function generateWorld() {\n            // Initialize InstancedMeshes\n            const geometry = new THREE.BoxGeometry(1, 1, 1);\n            \n            // Estimate max blocks per type (roughly)\n            const maxCount = WORLD_SIZE * WORLD_SIZE * CHUNK_HEIGHT / 2; \n\n            BLOCK_TYPES.forEach(type => {\n                const material = new THREE.MeshLambertMaterial({ \n                    color: type.color,\n                    transparent: type.transparent || false,\n                    opacity: type.opacity || 1.0\n                });\n                \n                const mesh = new THREE.InstancedMesh(geometry, material, maxCount);\n                mesh.castShadow = !type.transparent;\n                mesh.receiveShadow = true;\n                mesh.count = 0; // Start with 0 visible\n                scene.add(mesh);\n                meshes[type.id] = mesh;\n            });\n\n            // Terrain Generation\n            const instances = {}; // blockId -> array of matrices\n\n            const offset = WORLD_SIZE / 2;\n\n            for (let x = -offset; x < offset; x++) {\n                for (let z = -offset; z < offset; z++) {\n                    // Height map\n                    let n = noise(x, z);\n                    let height = Math.floor(n * 10) + 5; // Base height 5-15\n\n                    // Water level\n                    const waterLevel = 8;\n\n                    for (let y = 0; y <= height; y++) {\n                        let blockId = 1; // Grass\n\n                        if (y < height - 3) blockId = 3; // Stone deep down\n                        else if (y < height) blockId = 2; // Dirt\n                        \n                        // Sand near water\n                        if (y >= height - 1 && y <= waterLevel + 1) blockId = 6;\n\n                        // Trees (Random chance on grass)\n                        if (y === height && blockId === 1 && Math.random() > 0.98) {\n                            addTree(x, y + 1, z);\n                        }\n\n                        setBlockData(x, y, z, blockId);\n                    }\n\n                    // Fill water\n                    if (height < waterLevel) {\n                        for (let w = height + 1; w <= waterLevel; w++) {\n                            setBlockData(x, w, z, 7); // Water\n                        }\n                    }\n                }\n            }\n\n            rebuildMeshes();\n        }\n\n        function addTree(x, y, z) {\n            // Trunk\n            for(let i=0; i<4; i++) setBlockData(x, y+i, z, 4);\n            \n            // Leaves\n            for(let lx=-2; lx<=2; lx++) {\n                for(let lz=-2; lz<=2; lz++) {\n                    for(let ly=3; ly<=4; ly++) {\n                        if (Math.abs(lx) + Math.abs(lz) + Math.abs(ly-3) < 4) {\n                             setBlockData(x+lx, y+ly, z+lz, 5);\n                        }\n                    }\n                }\n            }\n            setBlockData(x, y+5, z, 5);\n        }\n\n        function setBlockData(x, y, z, id) {\n            const key = `${x},${y},${z}`;\n            if (id === 0) {\n                worldData.delete(key);\n            } else {\n                worldData.set(key, id);\n            }\n        }\n\n        function getBlockData(x, y, z) {\n            return worldData.get(`${x},${y},${z}`) || 0;\n        }\n\n        function rebuildMeshes() {\n            // Reset counts\n            BLOCK_TYPES.forEach(t => {\n                if(meshes[t.id]) meshes[t.id].count = 0;\n            });\n\n            const pos = new THREE.Vector3();\n            \n            worldData.forEach((id, key) => {\n                if (!meshes[id]) return;\n                \n                const [x, y, z] = key.split(',').map(Number);\n                pos.set(x, y, z);\n                \n                dummy.position.copy(pos);\n                dummy.updateMatrix();\n\n                const mesh = meshes[id];\n                mesh.setMatrixAt(mesh.count++, dummy.matrix);\n            });\n\n            // Update all\n            Object.values(meshes).forEach(mesh => mesh.instanceMatrix.needsUpdate = true);\n        }\n\n        // --- Physics & Interaction ---\n\n        function setupInputs() {\n            const onKeyDown = function (event) {\n                switch (event.code) {\n                    case 'ArrowUp':\n                    case 'KeyW': moveForward = true; break;\n                    case 'ArrowLeft':\n                    case 'KeyA': moveLeft = true; break;\n                    case 'ArrowDown':\n                    case 'KeyS': moveBackward = true; break;\n                    case 'ArrowRight':\n                    case 'KeyD': moveRight = true; break;\n                    case 'Space': if (canJump === true) { velocity.y += JUMP_FORCE; canJump = false; } break;\n                    case 'ShiftLeft': isCrouching = true; break;\n                    case 'Digit1': selectSlot(1); break;\n                    case 'Digit2': selectSlot(2); break;\n                    case 'Digit3': selectSlot(3); break;\n                    case 'Digit4': selectSlot(4); break;\n                    case 'Digit5': selectSlot(5); break;\n                }\n            };\n\n            const onKeyUp = function (event) {\n                switch (event.code) {\n                    case 'ArrowUp':\n                    case 'KeyW': moveForward = false; break;\n                    case 'ArrowLeft':\n                    case 'KeyA': moveLeft = false; break;\n                    case 'ArrowDown':\n                    case 'KeyS': moveBackward = false; break;\n                    case 'ArrowRight':\n                    case 'KeyD': moveRight = false; break;\n                    case 'ShiftLeft': isCrouching = false; break;\n                }\n            };\n\n            document.addEventListener('keydown', onKeyDown);\n            document.addEventListener('keyup', onKeyUp);\n\n            // Mouse Clicks\n            document.addEventListener('mousedown', (e) => {\n                if (!controls.isLocked) return;\n                if (e.button === 0) removeBlock(); // Left\n                if (e.button === 2) placeBlock(); // Right\n            });\n            \n            // Prevent context menu\n            document.addEventListener('contextmenu', e => e.preventDefault());\n        }\n\n        function selectSlot(index) {\n            if (index < 1 || index > 5) return;\n            selectedBlockId = index;\n            \n            // Update UI\n            document.querySelectorAll('.hotbar-slot').forEach((el, i) => {\n                if (i === index - 1) el.classList.add('active');\n                else el.classList.remove('active');\n            });\n        }\n\n        function setupUI() {\n            const container = document.getElementById('hotbar-container');\n            BLOCK_TYPES.slice(0, 5).forEach((type, index) => {\n                const div = document.createElement('div');\n                div.className = `hotbar-slot w-12 h-12 rounded-lg border-2 border-gray-500 flex items-center justify-center cursor-pointer relative ${index === 0 ? 'active' : ''}`;\n                div.style.backgroundColor = 'rgba(0,0,0,0.5)';\n                \n                // Color box\n                const colorBox = document.createElement('div');\n                colorBox.className = 'w-8 h-8 rounded shadow-sm';\n                colorBox.style.backgroundColor = type.color;\n                div.appendChild(colorBox);\n\n                // Key number\n                const num = document.createElement('span');\n                num.className = 'absolute top-0 left-1 text-[10px] font-bold text-gray-400';\n                num.innerText = index + 1;\n                div.appendChild(num);\n\n                div.onclick = () => selectSlot(index + 1);\n                container.appendChild(div);\n            });\n        }\n\n        function updatePhysics(delta) {\n            // Gravity\n            velocity.y -= GRAVITY * delta;\n\n            // Drag\n            velocity.x -= velocity.x * 10.0 * delta;\n            velocity.z -= velocity.z * 10.0 * delta;\n\n            // Input direction\n            direction.z = Number(moveForward) - Number(moveBackward);\n            direction.x = Number(moveRight) - Number(moveLeft);\n            direction.normalize();\n\n            const currentSpeed = isCrouching ? CROUCH_SPEED : SPEED;\n\n            if (moveForward || moveBackward) velocity.z -= direction.z * currentSpeed * delta * 50; // Acceleration\n            if (moveLeft || moveRight) velocity.x -= direction.x * currentSpeed * delta * 50;\n\n            // Move X\n            controls.moveRight(-velocity.x * delta);\n            checkCollision('x');\n\n            // Move Z\n            controls.moveForward(-velocity.z * delta);\n            checkCollision('z');\n\n            // Move Y (Jump/Fall)\n            camera.position.y += velocity.y * delta;\n            checkCollision('y');\n\n            // Simple floor check (hard limit)\n            if (camera.position.y < -20) {\n                velocity.y = 0;\n                camera.position.y = 25; // Respawn high\n                controls.getObject().position.y = 25;\n            }\n        }\n\n        function checkCollision(axis) {\n            // Player size approx 0.6 width, 1.8 height\n            // We check points around the player\n            const pos = camera.position;\n            const x = Math.floor(pos.x);\n            const y = Math.floor(pos.y - 1.6); // Feet\n            const z = Math.floor(pos.z);\n\n            // Very basic collision: if inside a block, push out\n            // This is a simplified version for the demo to avoid complex physics engine\n            \n            // Check feet and head\n            const blockFeet = getBlockData(Math.floor(pos.x), Math.floor(pos.y - 1.8), Math.floor(pos.z));\n            const blockHead = getBlockData(Math.floor(pos.x), Math.floor(pos.y - 0.5), Math.floor(pos.z));\n            const blockCenter = getBlockData(Math.floor(pos.x), Math.floor(pos.y - 1.0), Math.floor(pos.z));\n\n            if (blockFeet !== 0 && blockFeet !== 7) { // 7 is water\n                // Ground hit\n                velocity.y = Math.max(0, velocity.y);\n                canJump = true;\n                // Snap to top of block\n                // camera.position.y = Math.floor(pos.y) + 1.8; \n            }\n            \n            // Simple wall collision (push back if inside solid block)\n            // This is imperfect but works for basic terrain\n            if (blockCenter !== 0 && blockCenter !== 7) {\n                 if (axis === 'x') velocity.x = 0;\n                 if (axis === 'z') velocity.z = 0;\n                 if (axis === 'y') {\n                     if(velocity.y < 0) {\n                         velocity.y = 0;\n                         canJump = true;\n                     } else {\n                         velocity.y = 0;\n                     }\n                 }\n            }\n        }\n\n        function updateInteraction() {\n            raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);\n\n            // Create array of all instanced meshes\n            const interactables = Object.values(meshes);\n            const intersects = raycaster.intersectObjects(interactables);\n\n            if (intersects.length > 0) {\n                const intersect = intersects[0];\n                const matrix = new THREE.Matrix4();\n                intersect.object.getMatrixAt(intersect.instanceId, matrix);\n                const position = new THREE.Vector3().setFromMatrixPosition(matrix);\n\n                highlightMesh.position.copy(position);\n                highlightMesh.visible = true;\n\n                // Store for click handlers\n                window.currentLookAt = {\n                    position: position,\n                    normal: intersect.face.normal\n                };\n            } else {\n                highlightMesh.visible = false;\n                window.currentLookAt = null;\n            }\n        }\n\n        function removeBlock() {\n            if (!window.currentLookAt) return;\n            const pos = window.currentLookAt.position;\n            \n            // Check distance again to be sure\n            if (pos.distanceTo(camera.position) > REACH + 1) return;\n\n            const key = `${pos.x},${pos.y},${pos.z}`;\n            const id = worldData.get(key);\n            \n            if (id) {\n                // Remove data\n                worldData.delete(key);\n                \n                // Rebuild specific mesh (naive approach: rebuild all)\n                // Optimization: Just update the specific mesh instance (complex with InstancedMesh)\n                // For this demo, we rebuild the mesh array\n                rebuildMeshes();\n                \n                // Particle effect (simplified)\n                createParticles(pos, BLOCK_TYPES.find(b => b.id === id).color);\n            }\n        }\n\n        function placeBlock() {\n            if (!window.currentLookAt) return;\n            const pos = window.currentLookAt.position;\n            const normal = window.currentLookAt.normal;\n\n            const newPos = pos.clone().add(normal);\n            \n            // Don't place inside player\n            const playerPos = camera.position;\n            if (Math.abs(newPos.x - playerPos.x) < 0.8 && \n                Math.abs(newPos.z - playerPos.z) < 0.8 && \n                Math.abs(newPos.y - (playerPos.y - 1)) < 1.5) return;\n\n            setBlockData(newPos.x, newPos.y, newPos.z, selectedBlockId);\n            rebuildMeshes();\n        }\n\n        function createParticles(pos, color) {\n            // Simple visual feedback\n            // In a full engine, we'd spawn particles. \n            // Here we just flash the highlight box or rely on the block disappearing.\n        }\n\n        function updateDayNightCycle(time) {\n            // Cycle every 60 seconds\n            const cycleDuration = 60;\n            const t = (time % cycleDuration) / cycleDuration; // 0 to 1\n            \n            const angle = t * Math.PI * 2;\n            const r = 100;\n            \n            // Sun moves in a circle\n            window.sunLight.position.x = Math.cos(angle) * r;\n            window.sunLight.position.y = Math.sin(angle) * r;\n            \n            // Sky color changes\n            const dayColor = new THREE.Color(0x87CEEB);\n            const nightColor = new THREE.Color(0x0a0a2a);\n            const sunsetColor = new THREE.Color(0xfd5e53);\n            \n            let skyColor;\n            if (t > 0.4 && t < 0.6) { // Sunset/Sunrise\n                skyColor = sunsetColor;\n            } else if (t >= 0.6 || t <= 0.4) { // Night\n                 skyColor = nightColor.clone().lerp(sunsetColor, 0.1);\n            } else {\n                skyColor = dayColor;\n            }\n            \n            // Simple lerp based on height of sun\n            const intensity = Math.max(0, Math.sin(angle));\n            scene.background.lerp(skyColor, 0.05);\n            scene.fog.color.copy(scene.background);\n            window.sunLight.intensity = intensity * 0.8;\n        }\n\n        function animate() {\n            const time = performance.now();\n            const delta = (time - prevTime) / 1000;\n\n            if (controls.isLocked) {\n                updatePhysics(delta);\n                updateInteraction();\n                updateDayNightCycle(time / 1000);\n            }\n\n            // FPS Counter (rough)\n            if (Math.random() > 0.95) {\n                document.getElementById('fps-counter').innerText = Math.round(1 / delta);\n            }\n\n            prevTime = time;\n            renderer.render(scene, camera);\n        }\n\n        function onWindowResize() {\n            camera.aspect = window.innerWidth / window.innerHeight;\n            camera.updateProjectionMatrix();\n            renderer.setSize(window.innerWidth, window.innerHeight);\n        }\n\n        // Boot\n        init();\n\n    </script>\n</body>\n</html>\n```"
}