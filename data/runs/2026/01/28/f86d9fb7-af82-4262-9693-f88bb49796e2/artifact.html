<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Voxel Craft 3D</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { margin: 0; overflow: hidden; background-color: #87CEEB; user-select: none; }
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 20px;
            height: 20px;
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 20 20"><path d="M9 0h2v20H9z" fill="white" stroke="black" stroke-width="1"/><path d="M0 9h20v2H0z" fill="white" stroke="black" stroke-width="1"/></svg>');
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 10;
        }
        .hotbar-slot {
            transition: transform 0.1s, border-color 0.1s;
        }
        .hotbar-slot.active {
            transform: scale(1.1);
            border-color: white;
            box-shadow: 0 0 10px rgba(255,255,255,0.5);
        }
        /* Custom scrollbar for instructions if needed */
        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: rgba(0,0,0,0.1); }
        ::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.3); border-radius: 4px; }
    </style>
    <!-- Import Maps for Three.js -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body class="font-sans text-white">

    <!-- UI Overlay -->
    <div id="ui-layer" class="absolute inset-0 pointer-events-none flex flex-col justify-between p-6 z-20">
        
        <!-- Top Bar -->
        <div class="flex justify-between items-start">
            <div class="bg-black/50 backdrop-blur-sm p-4 rounded-lg border border-white/20">
                <h1 class="text-2xl font-bold bg-clip-text text-transparent bg-gradient-to-r from-green-400 to-blue-500">VOXEL CRAFT</h1>
                <p class="text-xs text-gray-300 mt-1">FPS: <span id="fps-counter">60</span></p>
            </div>
            
            <div class="bg-black/50 backdrop-blur-sm p-4 rounded-lg border border-white/20 text-right">
                <h2 class="font-bold text-yellow-400 mb-2">Controls</h2>
                <ul class="text-sm space-y-1 text-gray-200">
                    <li><span class="bg-white/20 px-1 rounded">W A S D</span> Move</li>
                    <li><span class="bg-white/20 px-1 rounded">SPACE</span> Jump</li>
                    <li><span class="bg-white/20 px-1 rounded">SHIFT</span> Crouch</li>
                    <li><span class="bg-white/20 px-1 rounded">L-Click</span> Break Block</li>
                    <li><span class="bg-white/20 px-1 rounded">R-Click</span> Place Block</li>
                    <li><span class="bg-white/20 px-1 rounded">1-5</span> Select Block</li>
                </ul>
            </div>
        </div>

        <!-- Crosshair -->
        <div id="crosshair"></div>

        <!-- Bottom Bar (Hotbar) -->
        <div class="flex justify-center mb-4">
            <div class="bg-black/60 backdrop-blur-md p-2 rounded-xl flex gap-2 border border-white/10">
                <!-- Generated by JS -->
                <div id="hotbar-container" class="flex gap-2"></div>
            </div>
        </div>
    </div>

    <!-- Start Screen -->
    <div id="start-screen" class="absolute inset-0 bg-black/80 z-50 flex items-center justify-center flex-col backdrop-blur-md">
        <h1 class="text-6xl font-black mb-4 text-transparent bg-clip-text bg-gradient-to-br from-green-400 via-blue-500 to-purple-600">VOXEL CRAFT</h1>
        <p class="text-xl text-gray-300 mb-8">Procedural World Generation • First Person • Sandbox</p>
        <button id="start-btn" class="px-8 py-4 bg-green-600 hover:bg-green-500 text-white font-bold rounded-lg text-xl transition transform hover:scale-105 shadow-[0_0_20px_rgba(34,197,94,0.6)]">
            CLICK TO START
        </button>
    </div>

    <!-- Game Canvas -->
    <canvas id="gl" class="block w-full h-full"></canvas>

    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

        // --- Configuration ---
        const WORLD_SIZE = 60; // Render distance radius
        const CHUNK_HEIGHT = 30;
        const GRAVITY = 30.0;
        const JUMP_FORCE = 10.0;
        const SPEED = 8.0;
        const CROUCH_SPEED = 4.0;
        const REACH = 6;

        // --- Block Types ---
        const BLOCK_TYPES = [
            { id: 1, name: 'Grass', color: '#5C9E63', sideColor: '#5d4037', bottomColor: '#5d4037' }, // Special handling for grass
            { id: 2, name: 'Dirt', color: '#5d4037' },
            { id: 3, name: 'Stone', color: '#757575' },
            { id: 4, name: 'Wood', color: '#3e2723' },
            { id: 5, name: 'Leaves', color: '#2e7d32', transparent: true },
            { id: 6, name: 'Sand', color: '#e6c075' },
            { id: 7, name: 'Water', color: '#29b6f6', transparent: true, opacity: 0.7 },
            { id: 8, name: 'Bricks', color: '#b71c1c' },
        ];

        // --- State ---
        let camera, scene, renderer, controls;
        let raycaster;
        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false, canJump = false;
        let isCrouching = false;
        let prevTime = performance.now();
        const velocity = new THREE.Vector3();
        const direction = new THREE.Vector3();
        
        // World Data: Map "x,y,z" -> blockId
        const worldData = new Map();
        const meshes = {}; // blockId -> InstancedMesh
        const dummy = new THREE.Object3D();
        let highlightMesh;
        
        let selectedBlockId = 1;
        
        // Simple Noise function (Simplex-like)
        // A simple pseudo-random noise generator to keep it self-contained
        function noise(x, z) {
            const sin = Math.sin;
            const cos = Math.cos;
            return (sin(x * 0.1) + cos(z * 0.1) + sin(x * 0.3 + z * 0.2) * 0.5) * 0.5 + 0.5;
        }

        // --- Initialization ---
        function init() {
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            scene.fog = new THREE.Fog(0x87CEEB, 10, WORLD_SIZE * 1.5);

            // Camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.y = 25; // Start high to fall down

            // Lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(50, 100, 50);
            dirLight.castShadow = true;
            dirLight.shadow.mapSize.width = 2048;
            dirLight.shadow.mapSize.height = 2048;
            dirLight.shadow.camera.near = 0.5;
            dirLight.shadow.camera.far = 500;
            dirLight.shadow.camera.left = -100;
            dirLight.shadow.camera.right = 100;
            dirLight.shadow.camera.top = 100;
            dirLight.shadow.camera.bottom = -100;
            scene.add(dirLight);
            
            // Day/Night Cycle Light (Sun/Moon)
            window.sunLight = dirLight;

            // Renderer
            renderer = new THREE.WebGLRenderer({ canvas: document.querySelector('#gl'), antialias: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;

            // Controls
            controls = new PointerLockControls(camera, document.body);

            const startBtn = document.getElementById('start-btn');
            const startScreen = document.getElementById('start-screen');

            startBtn.addEventListener('click', () => {
                controls.lock();
            });

            controls.addEventListener('lock', () => {
                startScreen.style.display = 'none';
            });

            controls.addEventListener('unlock', () => {
                startScreen.style.display = 'flex';
            });

            // Raycaster
            raycaster = new THREE.Raycaster();
            raycaster.far = REACH;

            // Highlight Block (Cursor)
            const hlGeo = new THREE.BoxGeometry(1.05, 1.05, 1.05);
            const hlMat = new THREE.MeshBasicMaterial({ color: 0x000000, wireframe: true, opacity: 0.5, transparent: true });
            highlightMesh = new THREE.Mesh(hlGeo, hlMat);
            scene.add(highlightMesh);
            highlightMesh.visible = false;

            // Generate World
            generateWorld();
            setupInputs();
            setupUI();

            // Resize Handler
            window.addEventListener('resize', onWindowResize);

            // Loop
            renderer.setAnimationLoop(animate);
        }

        function generateWorld() {
            // Initialize InstancedMeshes
            const geometry = new THREE.BoxGeometry(1, 1, 1);
            
            // Estimate max blocks per type (roughly)
            const maxCount = WORLD_SIZE * WORLD_SIZE * CHUNK_HEIGHT / 2; 

            BLOCK_TYPES.forEach(type => {
                const material = new THREE.MeshLambertMaterial({ 
                    color: type.color,
                    transparent: type.transparent || false,
                    opacity: type.opacity || 1.0
                });
                
                const mesh = new THREE.InstancedMesh(geometry, material, maxCount);
                mesh.castShadow = !type.transparent;
                mesh.receiveShadow = true;
                mesh.count = 0; // Start with 0 visible
                scene.add(mesh);
                meshes[type.id] = mesh;
            });

            // Terrain Generation
            const instances = {}; // blockId -> array of matrices

            const offset = WORLD_SIZE / 2;

            for (let x = -offset; x < offset; x++) {
                for (let z = -offset; z < offset; z++) {
                    // Height map
                    let n = noise(x, z);
                    let height = Math.floor(n * 10) + 5; // Base height 5-15

                    // Water level
                    const waterLevel = 8;

                    for (let y = 0; y <= height; y++) {
                        let blockId = 1; // Grass

                        if (y < height - 3) blockId = 3; // Stone deep down
                        else if (y < height) blockId = 2; // Dirt
                        
                        // Sand near water
                        if (y >= height - 1 && y <= waterLevel + 1) blockId = 6;

                        // Trees (Random chance on grass)
                        if (y === height && blockId === 1 && Math.random() > 0.98) {
                            addTree(x, y + 1, z);
                        }

                        setBlockData(x, y, z, blockId);
                    }

                    // Fill water
                    if (height < waterLevel) {
                        for (let w = height + 1; w <= waterLevel; w++) {
                            setBlockData(x, w, z, 7); // Water
                        }
                    }
                }
            }

            rebuildMeshes();
        }

        function addTree(x, y, z) {
            // Trunk
            for(let i=0; i<4; i++) setBlockData(x, y+i, z, 4);
            
            // Leaves
            for(let lx=-2; lx<=2; lx++) {
                for(let lz=-2; lz<=2; lz++) {
                    for(let ly=3; ly<=4; ly++) {
                        if (Math.abs(lx) + Math.abs(lz) + Math.abs(ly-3) < 4) {
                             setBlockData(x+lx, y+ly, z+lz, 5);
                        }
                    }
                }
            }
            setBlockData(x, y+5, z, 5);
        }

        function setBlockData(x, y, z, id) {
            const key = `${x},${y},${z}`;
            if (id === 0) {
                worldData.delete(key);
            } else {
                worldData.set(key, id);
            }
        }

        function getBlockData(x, y, z) {
            return worldData.get(`${x},${y},${z}`) || 0;
        }

        function rebuildMeshes() {
            // Reset counts
            BLOCK_TYPES.forEach(t => {
                if(meshes[t.id]) meshes[t.id].count = 0;
            });

            const pos = new THREE.Vector3();
            
            worldData.forEach((id, key) => {
                if (!meshes[id]) return;
                
                const [x, y, z] = key.split(',').map(Number);
                pos.set(x, y, z);
                
                dummy.position.copy(pos);
                dummy.updateMatrix();

                const mesh = meshes[id];
                mesh.setMatrixAt(mesh.count++, dummy.matrix);
            });

            // Update all
            Object.values(meshes).forEach(mesh => mesh.instanceMatrix.needsUpdate = true);
        }

        // --- Physics & Interaction ---

        function setupInputs() {
            const onKeyDown = function (event) {
                switch (event.code) {
                    case 'ArrowUp':
                    case 'KeyW': moveForward = true; break;
                    case 'ArrowLeft':
                    case 'KeyA': moveLeft = true; break;
                    case 'ArrowDown':
                    case 'KeyS': moveBackward = true; break;
                    case 'ArrowRight':
                    case 'KeyD': moveRight = true; break;
                    case 'Space': if (canJump === true) { velocity.y += JUMP_FORCE; canJump = false; } break;
                    case 'ShiftLeft': isCrouching = true; break;
                    case 'Digit1': selectSlot(1); break;
                    case 'Digit2': selectSlot(2); break;
                    case 'Digit3': selectSlot(3); break;
                    case 'Digit4': selectSlot(4); break;
                    case 'Digit5': selectSlot(5); break;
                }
            };

            const onKeyUp = function (event) {
                switch (event.code) {
                    case 'ArrowUp':
                    case 'KeyW': moveForward = false; break;
                    case 'ArrowLeft':
                    case 'KeyA': moveLeft = false; break;
                    case 'ArrowDown':
                    case 'KeyS': moveBackward = false; break;
                    case 'ArrowRight':
                    case 'KeyD': moveRight = false; break;
                    case 'ShiftLeft': isCrouching = false; break;
                }
            };

            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);

            // Mouse Clicks
            document.addEventListener('mousedown', (e) => {
                if (!controls.isLocked) return;
                if (e.button === 0) removeBlock(); // Left
                if (e.button === 2) placeBlock(); // Right
            });
            
            // Prevent context menu
            document.addEventListener('contextmenu', e => e.preventDefault());
        }

        function selectSlot(index) {
            if (index < 1 || index > 5) return;
            selectedBlockId = index;
            
            // Update UI
            document.querySelectorAll('.hotbar-slot').forEach((el, i) => {
                if (i === index - 1) el.classList.add('active');
                else el.classList.remove('active');
            });
        }

        function setupUI() {
            const container = document.getElementById('hotbar-container');
            BLOCK_TYPES.slice(0, 5).forEach((type, index) => {
                const div = document.createElement('div');
                div.className = `hotbar-slot w-12 h-12 rounded-lg border-2 border-gray-500 flex items-center justify-center cursor-pointer relative ${index === 0 ? 'active' : ''}`;
                div.style.backgroundColor = 'rgba(0,0,0,0.5)';
                
                // Color box
                const colorBox = document.createElement('div');
                colorBox.className = 'w-8 h-8 rounded shadow-sm';
                colorBox.style.backgroundColor = type.color;
                div.appendChild(colorBox);

                // Key number
                const num = document.createElement('span');
                num.className = 'absolute top-0 left-1 text-[10px] font-bold text-gray-400';
                num.innerText = index + 1;
                div.appendChild(num);

                div.onclick = () => selectSlot(index + 1);
                container.appendChild(div);
            });
        }

        function updatePhysics(delta) {
            // Gravity
            velocity.y -= GRAVITY * delta;

            // Drag
            velocity.x -= velocity.x * 10.0 * delta;
            velocity.z -= velocity.z * 10.0 * delta;

            // Input direction
            direction.z = Number(moveForward) - Number(moveBackward);
            direction.x = Number(moveRight) - Number(moveLeft);
            direction.normalize();

            const currentSpeed = isCrouching ? CROUCH_SPEED : SPEED;

            if (moveForward || moveBackward) velocity.z -= direction.z * currentSpeed * delta * 50; // Acceleration
            if (moveLeft || moveRight) velocity.x -= direction.x * currentSpeed * delta * 50;

            // Move X
            controls.moveRight(-velocity.x * delta);
            checkCollision('x');

            // Move Z
            controls.moveForward(-velocity.z * delta);
            checkCollision('z');

            // Move Y (Jump/Fall)
            camera.position.y += velocity.y * delta;
            checkCollision('y');

            // Simple floor check (hard limit)
            if (camera.position.y < -20) {
                velocity.y = 0;
                camera.position.y = 25; // Respawn high
                controls.getObject().position.y = 25;
            }
        }

        function checkCollision(axis) {
            // Player size approx 0.6 width, 1.8 height
            // We check points around the player
            const pos = camera.position;
            const x = Math.floor(pos.x);
            const y = Math.floor(pos.y - 1.6); // Feet
            const z = Math.floor(pos.z);

            // Very basic collision: if inside a block, push out
            // This is a simplified version for the demo to avoid complex physics engine
            
            // Check feet and head
            const blockFeet = getBlockData(Math.floor(pos.x), Math.floor(pos.y - 1.8), Math.floor(pos.z));
            const blockHead = getBlockData(Math.floor(pos.x), Math.floor(pos.y - 0.5), Math.floor(pos.z));
            const blockCenter = getBlockData(Math.floor(pos.x), Math.floor(pos.y - 1.0), Math.floor(pos.z));

            if (blockFeet !== 0 && blockFeet !== 7) { // 7 is water
                // Ground hit
                velocity.y = Math.max(0, velocity.y);
                canJump = true;
                // Snap to top of block
                // camera.position.y = Math.floor(pos.y) + 1.8; 
            }
            
            // Simple wall collision (push back if inside solid block)
            // This is imperfect but works for basic terrain
            if (blockCenter !== 0 && blockCenter !== 7) {
                 if (axis === 'x') velocity.x = 0;
                 if (axis === 'z') velocity.z = 0;
                 if (axis === 'y') {
                     if(velocity.y < 0) {
                         velocity.y = 0;
                         canJump = true;
                     } else {
                         velocity.y = 0;
                     }
                 }
            }
        }

        function updateInteraction() {
            raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);

            // Create array of all instanced meshes
            const interactables = Object.values(meshes);
            const intersects = raycaster.intersectObjects(interactables);

            if (intersects.length > 0) {
                const intersect = intersects[0];
                const matrix = new THREE.Matrix4();
                intersect.object.getMatrixAt(intersect.instanceId, matrix);
                const position = new THREE.Vector3().setFromMatrixPosition(matrix);

                highlightMesh.position.copy(position);
                highlightMesh.visible = true;

                // Store for click handlers
                window.currentLookAt = {
                    position: position,
                    normal: intersect.face.normal
                };
            } else {
                highlightMesh.visible = false;
                window.currentLookAt = null;
            }
        }

        function removeBlock() {
            if (!window.currentLookAt) return;
            const pos = window.currentLookAt.position;
            
            // Check distance again to be sure
            if (pos.distanceTo(camera.position) > REACH + 1) return;

            const key = `${pos.x},${pos.y},${pos.z}`;
            const id = worldData.get(key);
            
            if (id) {
                // Remove data
                worldData.delete(key);
                
                // Rebuild specific mesh (naive approach: rebuild all)
                // Optimization: Just update the specific mesh instance (complex with InstancedMesh)
                // For this demo, we rebuild the mesh array
                rebuildMeshes();
                
                // Particle effect (simplified)
                createParticles(pos, BLOCK_TYPES.find(b => b.id === id).color);
            }
        }

        function placeBlock() {
            if (!window.currentLookAt) return;
            const pos = window.currentLookAt.position;
            const normal = window.currentLookAt.normal;

            const newPos = pos.clone().add(normal);
            
            // Don't place inside player
            const playerPos = camera.position;
            if (Math.abs(newPos.x - playerPos.x) < 0.8 && 
                Math.abs(newPos.z - playerPos.z) < 0.8 && 
                Math.abs(newPos.y - (playerPos.y - 1)) < 1.5) return;

            setBlockData(newPos.x, newPos.y, newPos.z, selectedBlockId);
            rebuildMeshes();
        }

        function createParticles(pos, color) {
            // Simple visual feedback
            // In a full engine, we'd spawn particles. 
            // Here we just flash the highlight box or rely on the block disappearing.
        }

        function updateDayNightCycle(time) {
            // Cycle every 60 seconds
            const cycleDuration = 60;
            const t = (time % cycleDuration) / cycleDuration; // 0 to 1
            
            const angle = t * Math.PI * 2;
            const r = 100;
            
            // Sun moves in a circle
            window.sunLight.position.x = Math.cos(angle) * r;
            window.sunLight.position.y = Math.sin(angle) * r;
            
            // Sky color changes
            const dayColor = new THREE.Color(0x87CEEB);
            const nightColor = new THREE.Color(0x0a0a2a);
            const sunsetColor = new THREE.Color(0xfd5e53);
            
            let skyColor;
            if (t > 0.4 && t < 0.6) { // Sunset/Sunrise
                skyColor = sunsetColor;
            } else if (t >= 0.6 || t <= 0.4) { // Night
                 skyColor = nightColor.clone().lerp(sunsetColor, 0.1);
            } else {
                skyColor = dayColor;
            }
            
            // Simple lerp based on height of sun
            const intensity = Math.max(0, Math.sin(angle));
            scene.background.lerp(skyColor, 0.05);
            scene.fog.color.copy(scene.background);
            window.sunLight.intensity = intensity * 0.8;
        }

        function animate() {
            const time = performance.now();
            const delta = (time - prevTime) / 1000;

            if (controls.isLocked) {
                updatePhysics(delta);
                updateInteraction();
                updateDayNightCycle(time / 1000);
            }

            // FPS Counter (rough)
            if (Math.random() > 0.95) {
                document.getElementById('fps-counter').innerText = Math.round(1 / delta);
            }

            prevTime = time;
            renderer.render(scene, camera);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // Boot
        init();

    </script>
</body>
</html>