<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Web GTA - 3D City Adventure</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }
        #gameContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        #minimap {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 200px;
            height: 200px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid white;
            z-index: 1000;
        }
        #hud {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            z-index: 1000;
            font-size: 18px;
        }
        #missionPanel {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 15px;
            border-radius: 5px;
            z-index: 1000;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <div id="hud">
            <div>Health: <span id="health">100</span></div>
            <div>Vehicle: <span id="vehicleStatus">None</span></div>
        </div>
        <div id="missionPanel">
            <div class="mb-2 font-bold">Mission</div>
            <div id="missionText">Go to the waypoint!</div>
        </div>
        <canvas id="gameCanvas"></canvas>
        <div id="minimap"></div>
    </div>

    <script>
        class WebGTA {
            constructor() {
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                this.player = null;
                this.vehicles = [];
                this.currentVehicle = null;
                this.missionMarker = null;
                this.waypointReached = false;
                
                this.keys = {};
                this.speed = 0.1;
                this.turnSpeed = 0.05;
                this.vehicleSpeed = 0.5;
                this.vehicleTurnSpeed = 0.02;
                
                this.init();
            }

            init() {
                this.setupScene();
                this.createCity();
                this.createPlayer();
                this.createVehicles();
                this.createMissionMarker();
                this.setupEventListeners();
                this.animate();
            }

            setupScene() {
                this.scene = new THREE.Scene();
                this.scene.fog = new THREE.Fog(0x87CEEB, 50, 200);
                
                this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                this.camera.position.set(0, 10, 20);
                
                this.renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('gameCanvas'), antialias: true });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setClearColor(0x87CEEB);
                
                const ambientLight = new THREE.AmbientLight(0x404040);
                this.scene.add(ambientLight);
                
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight.position.set(50, 100, 50);
                this.scene.add(directionalLight);
            }

            createCity() {
                const roadMaterial = new THREE.MeshLambertMaterial({ color: 0x4D4D4D });
                const sidewalkMaterial = new THREE.MeshLambertMaterial({ color: 0x808080 });
                const buildingMaterial = new THREE.MeshLambertMaterial({ color: 0xB3B3B3 });
                
                // Create a simple grid of roads and buildings
                for (let i = -20; i < 20; i += 10) {
                    for (let j = -20; j < 20; j += 10) {
                        // Sidewalks
                        const sidewalkGeometry = new THREE.BoxGeometry(12, 0.2, 12);
                        const sidewalk = new THREE.Mesh(sidewalkGeometry, sidewalkMaterial);
                        sidewalk.position.set(i, -0.1, j);
                        this.scene.add(sidewalk);
                        
                        // Buildings
                        const buildingGeometry = new THREE.BoxGeometry(8, 10, 8);
                        const building = new THREE.Mesh(buildingGeometry, buildingMaterial);
                        building.position.set(i, 5, j);
                        this.scene.add(building);
                        
                        // Roads (alternating pattern)
                        if ((i + j) % 20 === 0) {
                            const roadGeometry = new THREE.PlaneGeometry(10, 10);
                            const road = new THREE.Mesh(roadGeometry, roadMaterial);
                            road.rotation.x = -Math.PI / 2;
                            road.position.set(i + 5, 0, j + 5);
                            this.scene.add(road);
                        }
                    }
                }
                
                // Central park area
                const parkGeometry = new THREE.PlaneGeometry(40, 40);
                const parkMaterial = new THREE.MeshLambertMaterial({ color: 0x228B22 });
                const park = new THREE.Mesh(parkGeometry, parkMaterial);
                park.rotation.x = -Math.PI / 2;
                park.position.set(0, 0.1, 0);
                this.scene.add(park);
            }

            createPlayer() {
                const playerGeometry = new THREE.BoxGeometry(1, 2, 1);
                const playerMaterial = new THREE.MeshLambertMaterial({ color: 0x0066FF });
                this.player = new THREE.Mesh(playerGeometry, playerMaterial);
                this.player.position.set(0, 1, 0);
                this.scene.add(this.player);
            }

            createVehicles() {
                const vehicleColors = [0xFF0000, 0x00FF00, 0x0000FF, 0xFFFF00, 0xFF00FF];
                
                for (let i = 0; i < 5; i++) {
                    const vehicleGeometry = new THREE.BoxGeometry(3, 1.5, 2);
                    const vehicleMaterial = new THREE.MeshLambertMaterial({ 
                        color: vehicleColors[i % vehicleColors.length] 
                    });
                    const vehicle = {
                        mesh: new THREE.Mesh(vehicleGeometry, vehicleMaterial),
                        velocity: new THREE.Vector3(),
                        acceleration: 0,
                        turnSpeed: 0
                    };
                    
                    vehicle.mesh.position.set(
                        (Math.random() - 0.5) * 40,
                        0.75,
                        (Math.random() - 0.5) * 40
                    );
                    vehicle.mesh.rotation.y = Math.random() * Math.PI * 2;
                    
                    this.vehicles.push(vehicle);
                    this.scene.add(vehicle.mesh);
                }
            }

            createMissionMarker() {
                const missionGeometry = new THREE.ConeGeometry(2, 4, 8);
                const missionMaterial = new THREE.MeshLambertMaterial({ 
                    color: 0xFF0000,
                    opacity: 0.7,
                    transparent: true
                });
                this.missionMarker = new THREE.Mesh(missionGeometry, missionMaterial);
                this.missionMarker.position.set(15, 0.1, 15);
                this.missionMarker.rotation.x = -Math.PI / 2;
                this.scene.add(this.missionMarker);
            }

            setupEventListeners() {
                window.addEventListener('keydown', (e) => {
                    this.keys[e.key.toLowerCase()] = true;
                    
                    // Enter vehicle
                    if (e.key.toLowerCase() === 'e') {
                        this.enterNearestVehicle();
                    }
                });
                
                window.addEventListener('keyup', (e) => {
                    this.keys[e.key.toLowerCase()] = false;
                });
                
                window.addEventListener('resize', () => {
                    this.camera.aspect = window.innerWidth / window.innerHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                });
            }

            enterNearestVehicle() {
                if (this.currentVehicle) return;
                
                const playerPos = this.player.position.clone();
                const nearbyVehicle = this.vehicles.find(vehicle => {
                    const distance = vehicle.mesh.position.distanceTo(playerPos);
                    return distance < 3;
                });
                
                if (nearbyVehicle) {
                    this.currentVehicle = nearbyVehicle;
                    this.scene.remove(this.player);
                    document.getElementById('vehicleStatus').textContent = 'Driving';
                }
            }

            updateMiniMap() {
                const minimap = document.getElementById('minimap');
                minimap.innerHTML = '';
                
                const canvas = document.createElement('canvas');
                canvas.width = 200;
                canvas.height = 200;
                const ctx = canvas.getContext('2d');
                
                ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                ctx.fillRect(0, 0, 200, 200);
                
                // Draw map elements
                const scale = 10;
                const offsetX = 100;
                const offsetY = 100;
                
                // Player/vehicle position
                const pos = this.currentVehicle ? this.currentVehicle.mesh.position : this.player.position;
                const x = offsetX + pos.x * scale;
                const z = offsetY - pos.z * scale;
                ctx.fillStyle = '#0066FF';
                ctx.fillRect(x - 2, z - 2, 4, 4);
                
                // Mission marker
                const markerX = offsetX + this.missionMarker.position.x * scale;
                const markerZ = offsetY - this.missionMarker.position.z * scale;
                ctx.fillStyle = '#FF0000';
                ctx.fillRect(markerX - 3, markerZ - 3, 6, 6);
                
                // Draw roads
                ctx.strokeStyle = '#4D4D4D';
                ctx.lineWidth = 2;
                for (let i = -20; i <= 20; i += 10) {
                    ctx.beginPath();
                    ctx.moveTo(offsetX + i * scale, 0);
                    ctx.lineTo(offsetX + i * scale, 200);
                    ctx.stroke();
                    
                    ctx.beginPath();
                    ctx.moveTo(0, offsetY + i * scale);
                    ctx.lineTo(200, offsetY + i * scale);
                    ctx.stroke();
                }
                
                minimap.appendChild(canvas);
            }

            checkWaypoint() {
                const pos = this.currentVehicle ? this.currentVehicle.mesh.position : this.player.position;
                const distance = pos.distanceTo(this.missionMarker.position);
                
                if (distance < 3 && !this.waypointReached) {
                    this.waypointReached = true;
                    this.missionMarker.material.color = new THREE.Color(0x00FF00);
                    document.getElementById('missionText').textContent = 'Waypoint reached! Mission complete!';
                }
            }

            updatePlayer() {
                if (this.currentVehicle) return;
                
                if (this.keys['w']) {
                    this.player.position.x -= Math.sin(this.player.rotation.y) * this.speed;
                    this.player.position.z -= Math.cos(this.player.rotation.y) * this.speed;
                }
                if (this.keys['s']) {
                    this.player.position.x += Math.sin(this.player.rotation.y) * this.speed;
                    this.player.position.z += Math.cos(this.player.rotation.y) * this.speed;
                }
                if (this.keys['a']) {
                    this.player.rotation.y += this.turnSpeed;
                }
                if (this.keys['d']) {
                    this.player.rotation.y -= this.turnSpeed;
                }
            }

            updateVehicle() {
                if (!this.currentVehicle) return;
                
                const vehicle = this.currentVehicle;
                
                if (this.keys['w']) {
                    vehicle.acceleration = this.vehicleSpeed;
                } else if (this.keys['s']) {
                    vehicle.acceleration = -this.vehicleSpeed;
                } else {
                    vehicle.acceleration *= 0.9; // Slow down gradually
                }
                
                if (this.keys['a']) {
                    vehicle.turnSpeed = this.vehicleTurnSpeed;
                } else if (this.keys['d']) {
                    vehicle.turnSpeed = -this.vehicleTurnSpeed;
                } else {
                    vehicle.turnSpeed = 0;
                }
                
                vehicle.velocity.x -= Math.sin(vehicle.mesh.rotation.y) * vehicle.acceleration;
                vehicle.velocity.z -= Math.cos(vehicle.mesh.rotation.y) * vehicle.acceleration;
                
                vehicle.mesh.rotation.y += vehicle.turnSpeed;
                vehicle.mesh.position.add(vehicle.velocity);
                vehicle.velocity.multiplyScalar(0.95); // Friction
                
                // Keep vehicle on roads (simple boundary check)
                if (Math.abs(vehicle.mesh.position.x) > 25) {
                    vehicle.mesh.position.x = Math.sign(vehicle.mesh.position.x) * 25;
                    vehicle.velocity.x = -vehicle.velocity.x * 0.5;
                }
                if (Math.abs(vehicle.mesh.position.z) > 25) {
                    vehicle.mesh.position.z = Math.sign(vehicle.mesh.position.z) * 25;
                    vehicle.velocity.z = -vehicle.velocity.z * 0.5;
                }
                
                // Simple collision with buildings (approximate)
                if (Math.abs(vehicle.mesh.position.x) < 15 && Math.abs(vehicle.mesh.position.z) < 15) {
                    vehicle.mesh.position.x += Math.sign(vehicle.mesh.position.x) * 0.1;
                    vehicle.mesh.position.z += Math.sign(vehicle.mesh.position.z) * 0.1;
                }
            }

            animate() {
                requestAnimationFrame(() => this.animate());
                
                this.updatePlayer();
                this.updateVehicle();
                this.checkWaypoint();
                this.updateMiniMap();
                
                if (this.currentVehicle) {
                    this.camera.position.copy(this.currentVehicle.mesh.position);
                    this.camera.position.y = 8;
                    this.camera.lookAt(this.currentVehicle.mesh.position);
                } else {
                    this.camera.position.x = this.player.position.x - Math.sin(this.player.rotation.y) * 10;
                    this.camera.position.y = 8;
                    this.camera.position.z = this.player.position.z - Math.cos(this.player.rotation.y) * 10;
                    this.camera.lookAt(this.player.position);
                }
                
                this.renderer.render(this.scene, this.camera);
            }
        }

        // Initialize the game when page loads
        window.addEventListener('load', () => {
            new WebGTA();
        });
    </script>
</div>
</body>
</html>