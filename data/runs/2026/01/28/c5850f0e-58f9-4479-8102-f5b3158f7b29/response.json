{
  "text": "```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Vice City Web: Open World</title>\n    <script src=\"https://cdn.tailwindcss.com\"></script>\n    <!-- Three.js Core -->\n    <script src=\"https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js\"></script>\n    <style>\n        body { margin: 0; overflow: hidden; background-color: #000; user-select: none; }\n        #canvas-container { width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; z-index: 1; }\n        .hud-text { font-family: 'Courier New', Courier, monospace; text-shadow: 1px 1px 0 #000; }\n        \n        /* Minimap Radar */\n        #minimap-container {\n            position: absolute;\n            top: 20px;\n            right: 20px;\n            width: 200px;\n            height: 200px;\n            border-radius: 50%;\n            border: 4px solid #333;\n            overflow: hidden;\n            background: rgba(20, 30, 20, 0.8);\n            z-index: 10;\n            box-shadow: 0 0 15px rgba(0,0,0,0.5);\n        }\n        #minimap {\n            width: 100%;\n            height: 100%;\n        }\n        \n        /* Floating Marker for Mission */\n        .marker {\n            position: absolute;\n            width: 20px;\n            height: 20px;\n            background: #00ff00;\n            border: 2px solid white;\n            border-radius: 50%;\n            transform: translate(-50%, -50%);\n            z-index: 5;\n            pointer-events: none;\n            box-shadow: 0 0 10px #00ff00;\n        }\n        .marker::after {\n            content: '';\n            position: absolute;\n            top: 100%;\n            left: 50%;\n            height: 40px;\n            width: 2px;\n            background: rgba(255,255,255,0.5);\n            transform: translateX(-50%);\n        }\n\n        /* CRT Effect Overlay */\n        .scanlines {\n            background: linear-gradient(\n                to bottom,\n                rgba(255,255,255,0),\n                rgba(255,255,255,0) 50%,\n                rgba(0,0,0,0.1) 50%,\n                rgba(0,0,0,0.1)\n            );\n            background-size: 100% 4px;\n            position: absolute;\n            top: 0; left: 0; right: 0; bottom: 0;\n            z-index: 20;\n            pointer-events: none;\n        }\n    </style>\n</head>\n<body>\n\n    <!-- 3D Canvas -->\n    <div id=\"canvas-container\"></div>\n\n    <!-- Scanlines -->\n    <div class=\"scanlines\"></div>\n\n    <!-- HUD -->\n    <div class=\"absolute top-0 left-0 w-full h-full pointer-events-none z-10 flex flex-col justify-between p-6\">\n        \n        <!-- Top Left: Stats -->\n        <div class=\"flex flex-col gap-1\">\n            <div class=\"text-green-400 text-2xl font-bold hud-text tracking-widest\">VICE<span class=\"text-white\">WEB</span></div>\n            <div id=\"speedometer\" class=\"hidden text-white text-4xl font-bold hud-text\">0 <span class=\"text-sm text-gray-400\">MPH</span></div>\n            <div id=\"gear-indicator\" class=\"hidden text-yellow-400 text-xl font-bold hud-text\">N</div>\n        </div>\n\n        <!-- Top Center: Zone -->\n        <div class=\"absolute top-6 left-1/2 transform -translate-x-1/2 text-center\">\n            <div id=\"zone-name\" class=\"text-white text-xl uppercase tracking-[0.3em] font-bold hud-text border-b-2 border-white pb-1\">DOWNTOWN</div>\n            <div id=\"mission-status\" class=\"text-green-400 text-sm mt-1 font-bold hud-text animate-pulse\">MISSION: GO TO MARKER</div>\n        </div>\n\n        <!-- Bottom Right: Controls -->\n        <div class=\"absolute bottom-6 right-6 text-right text-gray-300 text-xs font-mono space-y-1 opacity-70\">\n            <p><span class=\"text-white font-bold\">W A S D</span> Move / Drive</p>\n            <p><span class=\"text-white font-bold\">SPACE</span> Handbrake</p>\n            <p><span class=\"text-white font-bold\">F</span> Enter / Exit Vehicle</p>\n            <p><span class=\"text-white font-bold\">SHIFT</span> Run</p>\n            <p><span class=\"text-white font-bold\">C</span> Change Camera</p>\n        </div>\n\n        <!-- Weapon/Health -->\n        <div class=\"absolute bottom-6 left-6 flex flex-col gap-2\">\n            <div class=\"w-32 h-4 bg-gray-800 border border-gray-600\">\n                <div id=\"health-bar\" class=\"h-full bg-green-500 w-full transition-all duration-300\"></div>\n            </div>\n            <div class=\"text-white font-bold hud-text text-sm\">HEALTH</div>\n        </div>\n    </div>\n\n    <!-- Minimap -->\n    <div id=\"minimap-container\">\n        <canvas id=\"minimap\"></canvas>\n        <div class=\"absolute top-1/2 left-1/2 w-2 h-2 bg-white transform -translate-x-1/2 -translate-y-1/2 rotate-45 z-20\"></div>\n    </div>\n\n    <!-- Mission Marker (Projected to screen) -->\n    <div id=\"world-marker\" class=\"marker\"></div>\n\n    <!-- Start Screen -->\n    <div id=\"start-screen\" class=\"absolute inset-0 bg-black z-50 flex items-center justify-center flex-col\">\n        <h1 class=\"text-6xl text-green-500 font-bold hud-text mb-4 tracking-tighter\">VICE WEB</h1>\n        <p class=\"text-gray-400 mb-8 font-mono\">Open World Browser Experiment</p>\n        <button id=\"start-btn\" class=\"px-8 py-3 bg-green-600 hover:bg-green-500 text-white font-bold rounded shadow-[0_0_15px_rgba(0,255,0,0.5)] transition-all hud-text\">\n            START GAME\n        </button>\n    </div>\n\n    <script>\n        // --- Game Engine & Configuration ---\n        const CONFIG = {\n            worldSize: 800,\n            chunkSize: 40,\n            fogColor: 0x87CEEB,\n            fogDensity: 0.008,\n            gravity: 0.5,\n            playerSpeed: 0.8,\n            playerRunSpeed: 1.5,\n            carAcceleration: 0.05,\n            carMaxSpeed: 1.2,\n            carFriction: 0.96,\n            turnSpeed: 0.04\n        };\n\n        // --- Global State ---\n        let scene, camera, renderer, clock;\n        let player, currentVehicle = null;\n        let isDriving = false;\n        let cameraMode = 'third_person'; // third_person, hood, orbit\n        let keys = { w: false, a: false, s: false, d: false, shift: false, space: false };\n        let worldObjects = []; // For collision\n        let cars = [];\n        let missionTarget = null;\n        let minimapCtx, minimapCanvas;\n\n        // --- Audio Context ---\n        const AudioContext = window.AudioContext || window.webkitAudioContext;\n        const audioCtx = new AudioContext();\n\n        function playSound(type) {\n            if (audioCtx.state === 'suspended') audioCtx.resume();\n            const osc = audioCtx.createOscillator();\n            const gain = audioCtx.createGain();\n            osc.connect(gain);\n            gain.connect(audioCtx.destination);\n\n            const now = audioCtx.currentTime;\n            if (type === 'engine') {\n                osc.type = 'sawtooth';\n                osc.frequency.setValueAtTime(50 + Math.random() * 20, now);\n                gain.gain.setValueAtTime(0.05, now);\n                gain.gain.exponentialRampToValueAtTime(0.001, now + 0.1);\n                osc.start(now);\n                osc.stop(now + 0.1);\n            } else if (type === 'jump') {\n                osc.type = 'sine';\n                osc.frequency.setValueAtTime(150, now);\n                osc.frequency.exponentialRampToValueAtTime(300, now + 0.1);\n                gain.gain.setValueAtTime(0.1, now);\n                gain.gain.linearRampToValueAtTime(0, now + 0.1);\n                osc.start(now);\n                osc.stop(now + 0.1);\n            } else if (type === 'mission') {\n                osc.type = 'square';\n                osc.frequency.setValueAtTime(440, now);\n                osc.frequency.setValueAtTime(880, now + 0.1);\n                gain.gain.setValueAtTime(0.1, now);\n                gain.gain.linearRampToValueAtTime(0, now + 0.3);\n                osc.start(now);\n                osc.stop(now + 0.3);\n            }\n        }\n\n        // --- Initialization ---\n        function init() {\n            // Scene Setup\n            scene = new THREE.Scene();\n            scene.background = new THREE.Color(CONFIG.fogColor);\n            scene.fog = new THREE.FogExp2(CONFIG.fogColor, CONFIG.fogDensity);\n\n            // Camera\n            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);\n            \n            // Renderer\n            renderer = new THREE.WebGLRenderer({ antialias: true });\n            renderer.setSize(window.innerWidth, window.innerHeight);\n            renderer.shadowMap.enabled = true;\n            renderer.shadowMap.type = THREE.PCFSoftShadowMap;\n            document.getElementById('canvas-container').appendChild(renderer.domElement);\n\n            // Lights\n            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);\n            scene.add(ambientLight);\n\n            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);\n            dirLight.position.set(100, 200, 100);\n            dirLight.castShadow = true;\n            dirLight.shadow.mapSize.width = 2048;\n            dirLight.shadow.mapSize.height = 2048;\n            dirLight.shadow.camera.near = 0.5;\n            dirLight.shadow.camera.far = 500;\n            dirLight.shadow.camera.left = -200;\n            dirLight.shadow.camera.right = 200;\n            dirLight.shadow.camera.top = 200;\n            dirLight.shadow.camera.bottom = -200;\n            scene.add(dirLight);\n\n            // Minimap Setup\n            minimapCanvas = document.getElementById('minimap');\n            minimapCanvas.width = 200;\n            minimapCanvas.height = 200;\n            minimapCtx = minimapCanvas.getContext('2d');\n\n            // Generate World\n            generateCity();\n\n            // Create Player\n            createPlayer();\n\n            // Mission Setup\n            setNewMission();\n\n            // Event Listeners\n            window.addEventListener('resize', onWindowResize, false);\n            document.addEventListener('keydown', (e) => handleKey(e, true));\n            document.addEventListener('keyup', (e) => handleKey(e, false));\n            \n            document.getElementById('start-btn').addEventListener('click', () => {\n                document.getElementById('start-screen').style.display = 'none';\n                document.body.requestPointerLock();\n                loop();\n            });\n\n            // Unlock pointer on escape (optional, but good for browser games)\n            document.addEventListener('pointerlockchange', () => {\n                if (document.pointerLockElement !== document.body) {\n                    // Paused\n                }\n            });\n        }\n\n        // --- World Generation ---\n        function generateCity() {\n            // Ground\n            const groundGeo = new THREE.PlaneGeometry(CONFIG.worldSize * 2, CONFIG.worldSize * 2);\n            const groundMat = new THREE.MeshStandardMaterial({ color: 0x333333 });\n            const ground = new THREE.Mesh(groundGeo, groundMat);\n            ground.rotation.x = -Math.PI / 2;\n            ground.receiveShadow = true;\n            scene.add(ground);\n\n            // Grid System for Roads and Buildings\n            const gridDivisions = 20;\n            const step = CONFIG.worldSize / gridDivisions;\n            const cityOffset = -CONFIG.worldSize / 2;\n\n            // Road Texture Helper\n            function createRoad(x, z, w, d) {\n                const geo = new THREE.PlaneGeometry(w, d);\n                const mat = new THREE.MeshStandardMaterial({ color: 0x222222 });\n                const mesh = new THREE.Mesh(geo, mat);\n                mesh.rotation.x = -Math.PI / 2;\n                mesh.position.set(x, 0.05, z);\n                mesh.receiveShadow = true;\n                scene.add(mesh);\n\n                // Markings\n                const lineGeo = new THREE.PlaneGeometry(1, d);\n                const lineMat = new THREE.MeshBasicMaterial({ color: 0xFFFFFF });\n                const line = new THREE.Mesh(lineGeo, lineMat);\n                line.rotation.x = -Math.PI / 2;\n                line.position.set(x, 0.06, z);\n                if (w > d) line.rotation.z = Math.PI / 2; // Horizontal road\n                line.scale.set(0.1, 1, 1);\n                scene.add(line);\n            }\n\n            // Main Roads (Grid)\n            for (let i = 0; i <= gridDivisions; i++) {\n                const pos = cityOffset + i * step;\n                // Horizontal\n                createRoad(0, pos, CONFIG.worldSize, 20);\n                // Vertical\n                createRoad(pos, 0, 20, CONFIG.worldSize);\n            }\n\n            // Buildings & Props\n            const buildingColors = [0xcc5555, 0x55cc55, 0x5555cc, 0xcccc55, 0xcc55cc, 0x55cccc, 0x888888];\n            \n            for (let x = 0; x < gridDivisions; x++) {\n                for (let z = 0; z < gridDivisions; z++) {\n                    // Don't build on roads (every 2nd index is a road approx, but we used a specific grid above)\n                    // Simple logic: If x or z is even-ish, skip for road spacing? \n                    // Actually, let's just use coordinates.\n                    \n                    const cx = cityOffset + x * step + step/2;\n                    const cz = cityOffset + z * step + step/2;\n\n                    // Skip center intersections (simple distance check or modulo)\n                    // Roads are at 0, step*2, step*4...\n                    \n                    const isRoadX = Math.abs(cx % (step * 2)) < 15;\n                    const isRoadZ = Math.abs(cz % (step * 2)) < 15;\n\n                    if (!isRoadX && !isRoadZ) {\n                        // Building\n                        if (Math.random() > 0.2) {\n                            const h = 10 + Math.random() * 40;\n                            const w = step * 0.7;\n                            const d = step * 0.7;\n                            \n                            const geo = new THREE.BoxGeometry(w, h, d);\n                            const color = buildingColors[Math.floor(Math.random() * buildingColors.length)];\n                            const mat = new THREE.MeshStandardMaterial({ color: color });\n                            const mesh = new THREE.Mesh(geo, mat);\n                            mesh.position.set(cx, h / 2, cz);\n                            mesh.castShadow = true;\n                            mesh.receiveShadow = true;\n                            \n                            // Collision Data\n                            mesh.userData = { type: 'building', radius: w/1.5 }; // Approximation\n                            scene.add(mesh);\n                            worldObjects.push(mesh);\n                        } else {\n                            // Park/Empty space with trees\n                            const treeGeo = new THREE.ConeGeometry(2, 8, 8);\n                            const treeMat = new THREE.MeshStandardMaterial({ color: 0x228822 });\n                            const tree = new THREE.Mesh(treeGeo, treeMat);\n                            tree.position.set(cx, 4, cz);\n                            tree.castShadow = true;\n                            \n                            const trunkGeo = new THREE.CylinderGeometry(0.5, 0.5, 2);\n                            const trunkMat = new THREE.MeshStandardMaterial({ color: 0x8B4513 });\n                            const trunk = new THREE.Mesh(trunkGeo, trunkMat);\n                            trunk.position.y = -4;\n                            tree.add(trunk);\n                            \n                            tree.userData = { type: 'tree', radius: 1 };\n                            scene.add(tree);\n                            worldObjects.push(tree);\n                        }\n                    }\n                }\n            }\n\n            // Spawn Traffic Cars\n            for(let i=0; i<15; i++) {\n                spawnCar(true);\n            }\n        }\n\n        // --- Entities ---\n\n        class Car {\n            constructor(x, z, color) {\n                this.mesh = new THREE.Group();\n                \n                // Chassis\n                const chassisGeo = new THREE.BoxGeometry(2.2, 0.8, 4.5);\n                const chassisMat = new THREE.MeshStandardMaterial({ color: color || Math.random() * 0xffffff });\n                this.chassis = new THREE.Mesh(chassisGeo, chassisMat);\n                this.chassis.position.y = 0.8;\n                this.chassis.castShadow = true;\n                this.mesh.add(this.chassis);\n\n                // Wheels\n                const wheelGeo = new THREE.CylinderGeometry(0.4, 0.4, 0.3, 16);\n                const wheelMat = new THREE.MeshStandardMaterial({ color: 0x111111 });\n                const positions = [\n                    [-1.1, 0.4, 1.5], [1.1, 0.4, 1.5],\n                    [-1.1, 0.4, -1.5], [1.1, 0.4, -1.5]\n                ];\n                this.wheels = [];\n                positions.forEach(pos => {\n                    const w = new THREE.Mesh(wheelGeo, wheelMat);\n                    w.rotation.z = Math.PI / 2;\n                    w.position.set(...pos);\n                    this.mesh.add(w);\n                    this.wheels.push(w);\n                });\n\n                // Physics Props\n                this.position = new THREE.Vector3(x, 0, z);\n                this.velocity = new THREE.Vector3();\n                this.rotation = 0;\n                this.speed = 0;\n                this.isAI = true;\n                this.aiTarget = null;\n                this.aiTimer = 0;\n\n                this.mesh.position.copy(this.position);\n                scene.add(this.mesh);\n                cars.push(this);\n                worldObjects.push(this.mesh); // For collision\n                this.mesh.userData = { type: 'car', parent: this, radius: 2.5 };\n            }\n\n            update(dt) {\n                if (this === currentVehicle) {\n                    this.handleInput();\n                } else {\n                    this.handleAI();\n                }\n\n                // Physics\n                this.speed *= CONFIG.carFriction; // Drag\n                if (Math.abs(this.speed) < 0.001) this.speed = 0;\n\n                // Move\n                this.rotation += this.steering * dt * (this.speed * 0.5); // Steering effectiveness depends on speed\n                this.mesh.rotation.y = this.rotation;\n\n                const dx = Math.sin(this.rotation) * this.speed * 40 * dt; // Scale speed\n                const dz = Math.cos(this.rotation) * this.speed * 40 * dt;\n\n                const nextPos = this.mesh.position.clone();\n                nextPos.x -= dx;\n                nextPos.z -= dz;\n\n                // Simple Collision\n                if (!this.checkCollision(nextPos)) {\n                    this.mesh.position.copy(nextPos);\n                } else {\n                    this.speed *= -0.5; // Bounce\n                }\n\n                // Wheel Animation\n                this.wheels.forEach(w => {\n                    w.rotation.x += this.speed * 2;\n                });\n            }\n\n            handleInput() {\n                // Acceleration\n                if (keys.w) this.speed += CONFIG.carAcceleration;\n                if (keys.s) this.speed -= CONFIG.carAcceleration;\n                \n                // Steering\n                this.steering = 0;\n                if (keys.a) this.steering = CONFIG.turnSpeed;\n                if (keys.d) this.steering = -CONFIG.turnSpeed;\n\n                // Handbrake\n                if (keys.space) this.speed *= 0.9;\n            }\n\n            handleAI() {\n                this.aiTimer -= 0.01;\n                if (this.aiTimer <= 0) {\n                    this.aiTimer = 2 + Math.random() * 3;\n                    // Random behavior: Drive straight or turn\n                    this.aiTarget = Math.random() > 0.5 ? (Math.random() - 0.5) : 0;\n                    this.aiSpeed = 0.2 + Math.random() * 0.3;\n                }\n\n                // Simple AI: try to stay on road (basic logic)\n                // Just drive forward and turn sometimes\n                this.speed = this.speed * 0.9 + this.aiSpeed * 0.1; // Ease into speed\n                \n                // Avoid crashing by raycasting? Too complex for this snippet.\n                // Just basic turn logic.\n                this.steering = this.aiTarget * 0.5;\n            }\n\n            checkCollision(pos) {\n                // Check buildings\n                for (let obj of worldObjects) {\n                    if (obj === this.mesh) continue;\n                    if (obj.userData && obj.userData.type === 'building') {\n                        const dist = pos.distanceTo(obj.position);\n                        // Simple box distance approx\n                        if (dist < 5 + obj.userData.radius) return true;\n                    }\n                }\n                return false;\n            }\n        }\n\n        function spawnCar(randomPos = false) {\n            let x, z;\n            if (randomPos) {\n                x = (Math.random() - 0.5) * CONFIG.worldSize;\n                z = (Math.random() - 0.5) * CONFIG.worldSize;\n            } else {\n                x = player.mesh.position.x + 10;\n                z = player.mesh.position.z;\n            }\n            new Car(x, z);\n        }\n\n        function createPlayer() {\n            const geo = new THREE.CapsuleGeometry(0.5, 1, 4, 8);\n            const mat = new THREE.MeshStandardMaterial({ color: 0xff0000 });\n            player = {\n                mesh: new THREE.Mesh(geo, mat),\n                velocity: new THREE.Vector3(),\n                height: 1.5,\n                speed: 0,\n                angle: 0\n            };\n            player.mesh.position.y = player.height / 2;\n            player.mesh.castShadow = true;\n            scene.add(player.mesh);\n        }\n\n        // --- Game Logic ---\n\n        function handleKey(e, isDown) {\n            const k = e.key.toLowerCase();\n            if (keys.hasOwnProperty(k)) keys[k] = isDown;\n            \n            if (isDown && k === 'f') toggleVehicle();\n            if (isDown && k === 'c') toggleCamera();\n        }\n\n        function toggleVehicle() {\n            if (isDriving) {\n                // Exit\n                isDriving = false;\n                currentVehicle = null;\n                player.mesh.visible = true;\n                // Place player next to car\n                const carPos = cars.find(c => c.mesh === currentVehicle?.mesh)?.mesh.position;\n                if(carPos) {\n                     player.mesh.position.copy(carPos);\n                     player.mesh.position.x += 2;\n                }\n                \n                document.getElementById('speedometer').classList.add('hidden');\n                document.getElementById('gear-indicator').classList.add('hidden');\n            } else {\n                // Enter\n                // Find closest car\n                let closest = null;\n                let minDist = 5;\n\n                cars.forEach(car => {\n                    const dist = player.mesh.position.distanceTo(car.mesh.position);\n                    if (dist < minDist) {\n                        minDist = dist;\n                        closest = car;\n                    }\n                });\n\n                if (closest) {\n                    isDriving = true;\n                    currentVehicle = closest;\n                    currentVehicle.isAI = false;\n                    currentVehicle.speed = 0;\n                    player.mesh.visible = false;\n                    document.getElementById('speedometer').classList.remove('hidden');\n                    document.getElementById('gear-indicator').classList.remove('hidden');\n                }\n            }\n        }\n\n        function toggleCamera() {\n            const modes = ['third_person', 'hood', 'orbit'];\n            let idx = modes.indexOf(cameraMode);\n            idx = (idx + 1) % modes.length;\n            cameraMode = modes[idx];\n        }\n\n        function updatePlayer(dt) {\n            if (isDriving) return;\n\n            let speed = keys.shift ? CONFIG.playerRunSpeed : CONFIG.playerSpeed;\n            let moveSpeed = 0;\n            let turnSpeed = 0;\n\n            if (keys.w) moveSpeed = speed;\n            if (keys.s) moveSpeed = -speed;\n            if (keys.a) turnSpeed = 0.1;\n            if (keys.d) turnSpeed = -0.1;\n\n            // Rotation\n            if (moveSpeed !== 0) {\n                player.angle += turnSpeed;\n                player.mesh.rotation.y = player.angle;\n            } else if (keys.a || keys.d) {\n                // Strafe/Rotate in place\n                player.angle += turnSpeed * 2;\n                player.mesh.rotation.y = player.angle;\n            }\n\n            // Movement Vector\n            const dx = Math.sin(player.angle) * moveSpeed;\n            const dz = Math.cos(player.angle) * moveSpeed;\n\n            const nextPos = player.mesh.position.clone();\n            nextPos.x -= dx;\n            nextPos.z -= dz;\n\n            // Collision\n            if (!checkPlayerCollision(nextPos)) {\n                player.mesh.position.copy(nextPos);\n            }\n        }\n\n        function checkPlayerCollision(pos) {\n            for (let obj of worldObjects) {\n                if (obj === player.mesh) continue;\n                // Simple radius check\n                const dist = pos.distanceTo(obj.position);\n                const threshold = 1 + (obj.userData.radius || 1);\n                if (dist < threshold) return true;\n            }\n            return false;\n        }\n\n        function updateCamera() {\n            if (!player) return;\n\n            const target = isDriving ? currentVehicle.mesh : player.mesh;\n            \n            if (cameraMode === 'third_person') {\n                // Calculate ideal offset\n                const relativeOffset = new THREE.Vector3(0, 5, 10);\n                \n                // Apply rotation of target\n                const cameraOffset = relativeOffset.applyMatrix4(target.matrixWorld);\n\n                // Smoothly interpolate camera position\n                camera.position.lerp(cameraOffset, 0.1);\n                camera.lookAt(target.position);\n            } else if (cameraMode === 'hood') {\n                const relativeOffset = new THREE.Vector3(0, 1.5, 0.5);\n                const cameraOffset = relativeOffset.applyMatrix4(target.matrixWorld);\n                camera.position.copy(cameraOffset);\n                camera.lookAt(target.position.clone().sub(new THREE.Vector3(Math.sin(target.rotation.y)*10, 0, Math.cos(target.rotation.y)*10)));\n            } else {\n                // Orbit (simple follow high up)\n                camera.position.set(target.position.x, target.position.y + 50, target.position.z + 20);\n                camera.lookAt(target.position);\n            }\n        }\n\n        function updateMinimap() {\n            const ctx = minimapCtx;\n            const w = minimapCanvas.width;\n            const h = minimapCanvas.height;\n            const scale = 0.2; // Zoom level\n\n            ctx.clearRect(0, 0, w, h);\n\n            // Background\n            ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';\n            ctx.fillRect(0, 0, w, h);\n\n            const centerX = w / 2;\n            const centerY = h / 2;\n            \n            const target = isDriving ? currentVehicle.mesh : player.mesh;\n\n            // Draw Roads (Simple representation)\n            ctx.strokeStyle = '#333';\n            ctx.lineWidth = 2;\n            // We need to project world coordinates to minimap relative to player\n            // To save perf, we just draw a grid or static map.\n            // For this demo, let's draw the objects relative to player.\n\n            ctx.save();\n            ctx.translate(centerX, centerY);\n            ctx.rotate(-target.rotation.y); // Rotate map so player is always facing up\n\n            // Draw Buildings (Dots)\n            ctx.fillStyle = '#555';\n            worldObjects.forEach(obj => {\n                if (obj.userData.type === 'building' || obj.userData.type === 'tree') {\n                    const dx = (obj.position.x - target.position.x) * scale;\n                    const dy = (obj.position.z - target.position.z) * scale;\n                    ctx.fillRect(dx - 2, dy - 2, 4, 4);\n                }\n            });\n\n            // Draw Mission Target\n            if (missionTarget) {\n                const dx = (missionTarget.x - target.position.x) * scale;\n                const dy = (missionTarget.z - target.position.z) * scale;\n                ctx.fillStyle = '#00ff00';\n                ctx.beginPath();\n                ctx.arc(dx, dy, 4, 0, Math.PI*2);\n                ctx.fill();\n            }\n\n            ctx.restore();\n\n            // Draw Player (Center, fixed)\n            ctx.fillStyle = '#fff';\n            ctx.beginPath();\n            ctx.moveTo(centerX, centerY - 5);\n            ctx.lineTo(centerX - 3, centerY + 3);\n            ctx.lineTo(centerX + 3, centerY + 3);\n            ctx.fill();\n        }\n\n        function setNewMission() {\n            // Pick a random point on the map\n            const range = CONFIG.worldSize / 2 - 20;\n            missionTarget = {\n                x: (Math.random() - 0.5) * 2 * range,\n                y: 0,\n                z: (Math.random() - 0.5) * 2 * range\n            };\n            \n            // Visual Marker in 3D world\n            // (Projected to screen in render loop)\n            playSound('mission');\n        }\n\n        function updateMission() {\n            if (!missionTarget) return;\n            const target = isDriving ? currentVehicle.mesh : player.mesh;\n            const dist = target.position.distanceTo(new THREE.Vector3(missionTarget.x, missionTarget.y, missionTarget.z));\n\n            if (dist < 5) {\n                // Complete\n                playSound('mission');\n                setNewMission(); // Next mission\n            }\n\n            // Project to screen\n            const marker = document.getElementById('world-marker');\n            const vec = new THREE.Vector3(missionTarget.x, missionTarget.y + 10, missionTarget.z);\n            vec.project(camera);\n\n            const x = (vec.x * .5 + .5) * window.innerWidth;\n            const y = (-(vec.y * .5) + .5) * window.innerHeight;\n\n            // Check if behind camera\n            if (vec.z > 1) {\n                marker.style.display = 'none';\n            } else {\n                marker.style.display = 'block';\n                marker.style.left = `${x}px`;\n                marker.style.top = `${y}px`;\n            }\n        }\n\n        function updateHUD() {\n            if (isDriving) {\n                const speed = Math.abs(Math.round(currentVehicle.speed * 100));\n                document.getElementById('speedometer').innerHTML = `${speed} <span class=\"text-sm text-gray-400\">MPH</span>`;\n                \n                let gear = 'N';\n                if (currentVehicle.speed > 0.1) gear = 'D';\n                if (currentVehicle.speed < -0.1) gear = 'R';\n                document.getElementById('gear-indicator').innerText = gear;\n            }\n        }\n\n        // --- Main Loop ---\n        function loop() {\n            requestAnimationFrame(loop);\n\n            const dt = 0.016; // Approx 60fps\n\n            updatePlayer(dt);\n            \n            cars.forEach(car => car.update(dt));\n\n            updateCamera();\n            updateMinimap();\n            updateMission();\n            updateHUD();\n\n            renderer.render(scene, camera);\n        }\n\n        function onWindowResize() {\n            camera.aspect = window.innerWidth / window.innerHeight;\n            camera.updateProjectionMatrix();\n            renderer.setSize(window.innerWidth, window.innerHeight);\n        }\n\n        // Boot\n        init();\n\n    </script>\n</body>\n</html>\n```"
}